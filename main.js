/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => OpenRouterPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  apiKey: "",
  defaultModel: "google/gemini-2.0-flash-exp:free",
  systemMessage: "You are a helpful assistant.",
  cachedModels: [],
  lastModelUpdate: 0,
  showFreeModelsOnly: false,
  useWebSearch: false,
  useStreaming: false
};
var OpenRouterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings.apiKey && (this.settings.cachedModels.length === 0 || Date.now() - this.settings.lastModelUpdate > 24 * 60 * 60 * 1e3)) {
      await this.fetchOpenRouterModels();
    }
    const ribbonIconEl = this.addRibbonIcon("message-square", "OpenRouter Chat", (evt) => {
      this.activateView();
    });
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("OpenRouter Chat");
    this.addCommand({
      id: "open-openrouter-chat",
      name: "Open OpenRouter Chat",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "insert-openrouter-response",
      name: "Insert OpenRouter Response at Cursor",
      editorCallback: (editor, ctx) => {
        const selectedText = editor.getSelection();
        if (selectedText) {
          new OpenRouterPromptModal(this.app, this.settings, async (response) => {
            editor.replaceSelection(response);
          }, selectedText).open();
        } else {
          new import_obsidian.Notice("Please select text to use as prompt");
        }
      }
    });
    this.addCommand({
      id: "refresh-openrouter-models",
      name: "Refresh OpenRouter Models",
      callback: async () => {
        if (!this.settings.apiKey) {
          new import_obsidian.Notice("API key not set. Please set it in the settings.");
          return;
        }
        await this.fetchOpenRouterModels();
        new import_obsidian.Notice("OpenRouter models refreshed.");
      }
    });
    this.addSettingTab(new OpenRouterSettingTab(this.app, this));
    this.registerView("openrouter-chat-view", (leaf) => new OpenRouterChatView(leaf, this.settings));
    if (this.app.plugins.plugins["obsidian-hover-editor"]) {
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType("openrouter-chat-view");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType("openrouter-chat-view");
    if (leaves.length > 0) {
      workspace.revealLeaf(leaves[0]);
      return;
    }
    const leaf = workspace.getLeaf("split", "vertical");
    await leaf.setViewState({
      type: "openrouter-chat-view",
      active: true
    });
    workspace.revealLeaf(leaf);
  }
  async fetchOpenRouterModels() {
    try {
      const response = await fetch("https://openrouter.ai/api/v1/models", {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.apiKey}`,
          "HTTP-Referer": "https://obsidian.md",
          "X-Title": "Obsidian OpenRouter Plugin"
        }
      });
      if (!response.ok) {
        console.error("Failed to fetch models:", response.statusText);
        new import_obsidian.Notice(`Error fetching models: ${response.statusText}`);
        return false;
      }
      const data = await response.json();
      if (data.data && Array.isArray(data.data)) {
        this.settings.cachedModels = data.data.map((model) => {
          const providerId = model.id.split("/")[0];
          const providerName = providerId.charAt(0).toUpperCase() + providerId.slice(1);
          const modelName = model.name || model.id.split("/").pop();
          const isFreeByName = modelName.toLowerCase().includes("free") || model.description && model.description.toLowerCase().includes("free");
          return {
            id: model.id,
            name: modelName,
            provider: providerName,
            isFree: isFreeByName
          };
        });
        this.settings.cachedModels.sort((a, b) => {
          if (a.provider !== b.provider) {
            return a.provider.localeCompare(b.provider);
          }
          return a.name.localeCompare(b.name);
        });
        this.settings.lastModelUpdate = Date.now();
        await this.saveSettings();
        return true;
      }
      console.error("Unexpected response format:", data);
      return false;
    } catch (error) {
      console.error("Error fetching OpenRouter models:", error);
      new import_obsidian.Notice(`Error fetching models: ${error.message}`);
      return false;
    }
  }
  getModelsForDisplay(filterText = "", freeOnly = false) {
    let models = [];
    if (this.settings.cachedModels && this.settings.cachedModels.length > 0) {
      models = this.settings.cachedModels;
    } else {
      models = [
        { id: "google/gemini-2.0-flash-exp:free", name: "Gemini 2.0 Flash (Free)", provider: "Google", isFree: true },
        { id: "anthropic/claude-3-opus", name: "Claude 3 Opus", provider: "Anthropic", isFree: false },
        { id: "anthropic/claude-3-sonnet", name: "Claude 3 Sonnet", provider: "Anthropic", isFree: false },
        { id: "anthropic/claude-3-haiku", name: "Claude 3 Haiku", provider: "Anthropic", isFree: false },
        { id: "meta-llama/llama-3-70b-instruct", name: "Llama 3 70B", provider: "Meta", isFree: false },
        { id: "meta-llama/llama-3-8b-instruct", name: "Llama 3 8B (Free)", provider: "Meta", isFree: true },
        { id: "openai/gpt-4-turbo", name: "GPT-4 Turbo", provider: "OpenAI", isFree: false },
        { id: "openai/gpt-4o", name: "GPT-4o", provider: "OpenAI", isFree: false },
        { id: "openai/gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: "OpenAI", isFree: false },
        { id: "google/gemini-pro", name: "Gemini Pro (Free)", provider: "Google", isFree: true },
        { id: "google/gemini-1.5-pro", name: "Gemini 1.5 Pro", provider: "Google", isFree: false },
        { id: "mistralai/mistral-large", name: "Mistral Large", provider: "Mistral", isFree: false },
        { id: "mistralai/mistral-medium", name: "Mistral Medium", provider: "Mistral", isFree: false },
        { id: "mistralai/mistral-small", name: "Mistral Small (Free)", provider: "Mistral", isFree: true },
        { id: "anthropic/claude-2", name: "Claude 2", provider: "Anthropic", isFree: false },
        { id: "cohere/command-r", name: "Command R", provider: "Cohere", isFree: false },
        { id: "cohere/command-r-plus", name: "Command R+", provider: "Cohere", isFree: false }
      ];
    }
    return models.filter((model) => {
      if (freeOnly && !model.name.toLowerCase().includes("free")) {
        return false;
      }
      if (filterText && !model.name.toLowerCase().includes(filterText.toLowerCase()) && !model.id.toLowerCase().includes(filterText.toLowerCase()) && !model.provider.toLowerCase().includes(filterText.toLowerCase())) {
        return false;
      }
      return true;
    });
  }
  async callOpenRouter(message) {
    const leaves = this.app.workspace.getLeavesOfType("openrouter-chat-view");
    if (leaves.length > 0) {
      const view = leaves[0].view;
      if (view) {
        await view.sendMessage();
      }
    }
  }
};
var OpenRouterChatView = class extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.messages = [];
    this.isProcessing = false;
    this.startTime = 0;
    this.firstTokenTime = 0;
    this.totalTokens = 0;
    this.endTime = 0;
    this.settings = settings;
    this.plugin = this.app.plugins.getPlugin("openrouter");
  }
  getViewType() {
    return "openrouter-chat-view";
  }
  getDisplayText() {
    return "OpenRouter Chat";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    const container = this.containerEl;
    container.empty();
    container.addClass("openrouter-chat-container");
    const headerEl = container.createEl("div", { cls: "openrouter-chat-header" });
    headerEl.createEl("h3", { text: "OpenRouter Chat" });
    const modelSelectContainer = headerEl.createEl("div", { cls: "openrouter-model-select-container" });
    const modelLabelContainer = modelSelectContainer.createEl("div", { cls: "openrouter-model-label-container" });
    modelLabelContainer.createEl("span", { text: "Model: " });
    const refreshButton = modelLabelContainer.createEl("button", {
      cls: "openrouter-refresh-button",
      attr: {
        title: "Refresh models list",
        "aria-label": "Refresh models list"
      }
    });
    refreshButton.innerHTML = "\u27F3";
    this.webSearchButton = modelLabelContainer.createEl("button", {
      cls: `openrouter-websearch-button ${this.settings.useWebSearch ? "active" : ""}`,
      attr: {
        title: "Toggle web search",
        "aria-label": "Toggle web search"
      }
    });
    this.webSearchButton.innerHTML = "\u{1F310}";
    this.webSearchButton.addEventListener("click", () => {
      this.settings.useWebSearch = !this.settings.useWebSearch;
      if (this.settings.useWebSearch) {
        this.webSearchButton.addClass("active");
      } else {
        this.webSearchButton.removeClass("active");
      }
      this.plugin.saveSettings();
    });
    this.modelSelect = modelSelectContainer.createEl("select", { cls: "openrouter-model-select" });
    const filterContainer = headerEl.createEl("div", { cls: "openrouter-model-filter" });
    const searchContainer = filterContainer.createEl("div", { cls: "openrouter-model-search-container" });
    const searchInput = searchContainer.createEl("input", {
      cls: "openrouter-model-search",
      attr: {
        type: "text",
        placeholder: "Search models..."
      }
    });
    const freeModelsContainer = filterContainer.createEl("div", { cls: "openrouter-free-models-toggle" });
    const freeModelsLabel = freeModelsContainer.createEl("label", {
      cls: "openrouter-free-models-label",
      text: "Free models only"
    });
    const freeModelsCheckbox = freeModelsLabel.createEl("input", {
      attr: {
        type: "checkbox",
        name: "free-models-only"
      }
    });
    freeModelsLabel.prepend(freeModelsCheckbox);
    freeModelsCheckbox.checked = this.settings.showFreeModelsOnly;
    this.populateModelSelect("", freeModelsCheckbox.checked);
    searchInput.addEventListener("input", () => {
      const searchText = searchInput.value;
      this.populateModelSelect(searchText, freeModelsCheckbox.checked);
    });
    freeModelsCheckbox.addEventListener("change", () => {
      this.settings.showFreeModelsOnly = freeModelsCheckbox.checked;
      this.plugin.saveSettings();
      this.populateModelSelect(searchInput.value, freeModelsCheckbox.checked);
    });
    refreshButton.addEventListener("click", async () => {
      if (!this.settings.apiKey) {
        new import_obsidian.Notice("API key not set. Please set it in the settings.");
        return;
      }
      refreshButton.disabled = true;
      refreshButton.innerHTML = "\u231B";
      const success = await this.plugin.fetchOpenRouterModels();
      refreshButton.disabled = false;
      refreshButton.innerHTML = "\u27F3";
      if (success) {
        new import_obsidian.Notice("Models refreshed successfully");
        this.populateModelSelect(searchInput.value, freeModelsCheckbox.checked);
      }
    });
    this.inputContainer = container.createEl("div", { cls: "openrouter-input-container" });
    this.textarea = this.inputContainer.createEl("textarea", {
      cls: "openrouter-input",
      attr: { placeholder: "Type your message here..." }
    });
    const sendButton = this.inputContainer.createEl("button", {
      cls: "openrouter-send-button",
      text: "Send"
    });
    const clearButton = this.inputContainer.createEl("button", {
      cls: "openrouter-clear-button",
      text: "Clear Chat"
    });
    this.messagesContainer = container.createEl("div", { cls: "openrouter-messages-container" });
    sendButton.addEventListener("click", () => this.sendMessage());
    this.textarea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
    clearButton.addEventListener("click", () => this.clearChat());
    this.messages = [{ role: "system", content: this.settings.systemMessage }];
  }
  populateModelSelect(searchText = "", freeOnly = false) {
    this.modelSelect.innerHTML = "";
    const models = this.plugin.getModelsForDisplay(searchText, freeOnly);
    const modelsByProvider = {};
    models.forEach((model) => {
      if (!modelsByProvider[model.provider]) {
        modelsByProvider[model.provider] = [];
      }
      modelsByProvider[model.provider].push(model);
    });
    Object.keys(modelsByProvider).sort().forEach((provider) => {
      const optgroup = document.createElement("optgroup");
      optgroup.label = provider;
      this.modelSelect.appendChild(optgroup);
      modelsByProvider[provider].forEach((model) => {
        let displayName = model.name;
        if (model.isFree && !model.name.toLowerCase().includes("free")) {
          displayName += " (Free)";
        }
        const option = document.createElement("option");
        option.value = model.id;
        option.text = displayName;
        if (model.id === this.settings.defaultModel) {
          option.selected = true;
        }
        optgroup.appendChild(option);
      });
    });
    if (models.length === 0) {
      const option = document.createElement("option");
      option.value = "";
      option.text = "No models match the filter";
      option.disabled = true;
      option.selected = true;
      this.modelSelect.appendChild(option);
    }
  }
  async sendMessage() {
    const content = this.textarea.value.trim();
    if (!content || this.isProcessing)
      return;
    this.isProcessing = true;
    this.textarea.value = "";
    this.startTime = Date.now();
    this.firstTokenTime = 0;
    this.totalTokens = 0;
    this.addMessageToUI("user", content);
    this.messages.push({ role: "user", content });
    const thinkingId = this.addThinkingIndicator();
    try {
      const response = await this.callOpenRouter(content);
      this.removeThinkingIndicator(thinkingId);
      this.endTime = Date.now();
      this.firstTokenTime = this.firstTokenTime || this.endTime;
      this.totalTokens = response.length / 4;
      this.messages.push({ role: "assistant", content: response });
      this.addMessageToUI("assistant", response);
    } catch (error) {
      console.error("Error calling OpenRouter:", error);
      this.removeThinkingIndicator(thinkingId);
      new import_obsidian.Notice(`Error: ${error.message}`);
      this.addMessageToUI("error", `Error: ${error.message}`);
    }
    this.isProcessing = false;
  }
  addThinkingIndicator() {
    const id = "thinking-" + Date.now();
    const thinkingEl = this.messagesContainer.createEl("div", {
      cls: "openrouter-thinking",
      attr: { id }
    });
    thinkingEl.setText("Thinking...");
    this.messagesContainer.scrollTo({
      top: this.messagesContainer.scrollHeight,
      behavior: "smooth"
    });
    return id;
  }
  removeThinkingIndicator(id) {
    const thinkingEl = this.messagesContainer.querySelector(`#${id}`);
    if (thinkingEl) {
      thinkingEl.remove();
    }
  }
  addMessageToUI(role, content) {
    const messageEl = this.messagesContainer.createEl("div", {
      cls: `openrouter-message openrouter-message-${role}`
    });
    const roleEl = messageEl.createEl("div", {
      cls: "openrouter-message-role",
      text: role.charAt(0).toUpperCase() + role.slice(1)
    });
    const contentEl = messageEl.createEl("div", { cls: "openrouter-message-content" });
    const markdownDiv = contentEl.createEl("div");
    import_obsidian.MarkdownRenderer.renderMarkdown(content, markdownDiv, "", this);
    if (role === "assistant") {
      const copyButton = messageEl.createEl("button", {
        cls: "openrouter-copy-button",
        attr: {
          "aria-label": "Copy message",
          "title": "Copy to clipboard"
        },
        text: "\u{1F4CB}"
      });
      copyButton.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(content);
          copyButton.setText("\u2713");
          copyButton.addClass("copied");
          setTimeout(() => {
            copyButton.setText("\u{1F4CB}");
            copyButton.removeClass("copied");
          }, 2e3);
        } catch (err) {
          console.error("Failed to copy text: ", err);
          new import_obsidian.Notice("Failed to copy to clipboard");
        }
      });
      if (this.endTime > 0) {
        this.addMetricsButton(messageEl);
      }
    }
    this.messagesContainer.scrollTo({
      top: this.messagesContainer.scrollHeight,
      behavior: "smooth"
    });
  }
  clearChat() {
    this.messagesContainer.empty();
    this.messages = [{ role: "system", content: this.settings.systemMessage }];
  }
  async callOpenRouterStreaming(content, thinkingId) {
    var _a, _b;
    if (!this.settings.apiKey) {
      throw new Error("OpenRouter API key not set. Please set it in the settings.");
    }
    const selectedModel = this.modelSelect.value;
    let modelId = selectedModel;
    if (this.settings.useWebSearch) {
      modelId = `${selectedModel}:online`;
    }
    try {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`,
          "HTTP-Referer": "https://obsidian.md",
          "X-Title": "Obsidian OpenRouter Plugin"
        },
        body: JSON.stringify({
          model: modelId,
          messages: this.messages,
          stream: true
        })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(((_a = errorData.error) == null ? void 0 : _a.message) || `HTTP error! status: ${response.status}`);
      }
      const tempDiv = document.createElement("div");
      let responseContent = "";
      const reader = (_b = response.body) == null ? void 0 : _b.getReader();
      if (!reader)
        throw new Error("Failed to get response reader");
      this.removeThinkingIndicator(thinkingId);
      const messageEl = this.messagesContainer.createEl("div", {
        cls: "openrouter-message openrouter-message-assistant"
      });
      const roleEl = messageEl.createEl("div", {
        cls: "openrouter-message-role",
        text: "Assistant"
      });
      const contentEl = messageEl.createEl("div", { cls: "openrouter-message-content" });
      const markdownDiv = contentEl.createEl("div");
      let firstTokenReceived = false;
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            if (data === "[DONE]")
              continue;
            try {
              const parsed = JSON.parse(data);
              const content2 = parsed.choices[0].delta.content || "";
              if (content2 && !firstTokenReceived) {
                firstTokenReceived = true;
                this.firstTokenTime = Date.now();
              }
              responseContent += content2;
              this.totalTokens++;
              import_obsidian.MarkdownRenderer.renderMarkdown(responseContent, markdownDiv, "", this);
              this.messagesContainer.scrollTo({
                top: this.messagesContainer.scrollHeight,
                behavior: "smooth"
              });
            } catch (e) {
            }
          }
        }
      }
      this.endTime = Date.now();
      this.messages.push({ role: "assistant", content: responseContent });
      const copyButton = messageEl.createEl("button", {
        cls: "openrouter-copy-button",
        attr: {
          "aria-label": "Copy message",
          "title": "Copy to clipboard"
        },
        text: "\u{1F4CB}"
      });
      copyButton.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(responseContent);
          copyButton.setText("\u2713");
          copyButton.addClass("copied");
          setTimeout(() => {
            copyButton.setText("\u{1F4CB}");
            copyButton.removeClass("copied");
          }, 2e3);
        } catch (err) {
          console.error("Failed to copy text: ", err);
          new import_obsidian.Notice("Failed to copy to clipboard");
        }
      });
      this.addMetricsButton(messageEl);
    } catch (error) {
      console.error("Error in streaming response:", error);
      throw error;
    }
  }
  addMetricsButton(messageEl) {
    const totalTime = this.endTime - this.startTime;
    const timeToFirstToken = this.firstTokenTime - this.startTime;
    const tokensPerSecond = this.totalTokens / (totalTime / 1e3);
    const metricsButton = messageEl.createEl("button", {
      cls: "openrouter-metrics-button",
      attr: {
        "aria-label": "Response metrics",
        "title": "Response metrics"
      },
      text: "\u{1F4CA}"
    });
    const metricsPopup = messageEl.createEl("div", {
      cls: "openrouter-metrics-popup"
    });
    metricsPopup.createEl("div", {
      text: `Time to first token: ${timeToFirstToken}ms`
    });
    metricsPopup.createEl("div", {
      text: `Total time: ${totalTime}ms`
    });
    metricsPopup.createEl("div", {
      text: `Est. tokens: ${this.totalTokens}`
    });
    metricsPopup.createEl("div", {
      text: `Est. tokens/sec: ${tokensPerSecond.toFixed(2)}`
    });
    metricsPopup.style.display = "none";
    metricsButton.addEventListener("mouseenter", () => {
      metricsPopup.style.display = "block";
    });
    metricsButton.addEventListener("mouseleave", () => {
      metricsPopup.style.display = "none";
    });
  }
  async callOpenRouter(content) {
    var _a;
    if (!this.settings.apiKey) {
      throw new Error("OpenRouter API key not set. Please set it in the settings.");
    }
    const selectedModel = this.modelSelect.value;
    let modelId = selectedModel;
    if (this.settings.useWebSearch) {
      modelId = `${selectedModel}:online`;
    }
    try {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.apiKey}`,
          "HTTP-Referer": "https://obsidian.md",
          "X-Title": "Obsidian OpenRouter Plugin"
        },
        body: JSON.stringify({
          model: modelId,
          messages: this.messages,
          stream: false
        })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(((_a = errorData.error) == null ? void 0 : _a.message) || `HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      this.firstTokenTime = Date.now();
      return data.choices[0].message.content;
    } catch (error) {
      console.error("Error calling OpenRouter:", error);
      throw error;
    }
  }
};
var OpenRouterPromptModal = class extends import_obsidian.Modal {
  constructor(app, settings, onSubmit, prompt) {
    super(app);
    this.resultText = "";
    this.isProcessing = false;
    this.settings = settings;
    this.onSubmit = onSubmit;
    this.prompt = prompt;
    this.plugin = app.plugins.getPlugin("openrouter");
  }
  populateModelSelect(selectEl, searchText = "", freeOnly = false) {
    selectEl.innerHTML = "";
    const models = this.plugin.getModelsForDisplay(searchText, freeOnly);
    const modelsByProvider = {};
    models.forEach((model) => {
      if (!modelsByProvider[model.provider]) {
        modelsByProvider[model.provider] = [];
      }
      modelsByProvider[model.provider].push(model);
    });
    Object.keys(modelsByProvider).sort().forEach((provider) => {
      const optgroup = selectEl.createEl("optgroup", {
        attr: { label: provider }
      });
      modelsByProvider[provider].forEach((model) => {
        let displayName = model.name;
        if (model.isFree && !model.name.toLowerCase().includes("free")) {
          displayName += " (Free)";
        }
        const option = optgroup.createEl("option", {
          value: model.id,
          text: displayName
        });
        if (model.id === this.settings.defaultModel) {
          option.selected = true;
        }
      });
    });
    if (models.length === 0) {
      const option = selectEl.createEl("option", {
        value: "",
        text: "No models match the filter",
        attr: { disabled: true }
      });
      option.selected = true;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("openrouter-modal");
    contentEl.createEl("h2", { text: "OpenRouter Prompt" });
    const modelContainer = contentEl.createEl("div", { cls: "openrouter-modal-model-container" });
    const modelLabelContainer = modelContainer.createEl("div", { cls: "openrouter-model-label-container" });
    modelLabelContainer.createEl("label", { text: "Select model:" });
    const refreshButton = modelLabelContainer.createEl("button", {
      cls: "openrouter-refresh-button",
      attr: {
        title: "Refresh models list",
        "aria-label": "Refresh models list"
      }
    });
    refreshButton.innerHTML = "\u27F3";
    const filterContainer = modelContainer.createEl("div", { cls: "openrouter-model-filter" });
    const searchContainer = filterContainer.createEl("div", { cls: "openrouter-model-search-container" });
    const searchInput = searchContainer.createEl("input", {
      cls: "openrouter-model-search",
      attr: {
        type: "text",
        placeholder: "Search models..."
      }
    });
    const freeModelsContainer = filterContainer.createEl("div", { cls: "openrouter-free-models-toggle" });
    const freeModelsLabel = freeModelsContainer.createEl("label", {
      cls: "openrouter-free-models-label",
      text: "Free models only"
    });
    const freeModelsCheckbox = freeModelsLabel.createEl("input", {
      attr: {
        type: "checkbox",
        name: "free-models-only"
      }
    });
    freeModelsLabel.prepend(freeModelsCheckbox);
    freeModelsCheckbox.checked = this.plugin.settings.showFreeModelsOnly;
    const modelSelect = modelContainer.createEl("select", { cls: "openrouter-modal-model-select" });
    this.populateModelSelect(modelSelect, "", freeModelsCheckbox.checked);
    searchInput.addEventListener("input", () => {
      const searchText = searchInput.value;
      this.populateModelSelect(modelSelect, searchText, freeModelsCheckbox.checked);
    });
    freeModelsCheckbox.addEventListener("change", () => {
      this.plugin.settings.showFreeModelsOnly = freeModelsCheckbox.checked;
      this.plugin.saveSettings();
      this.populateModelSelect(modelSelect, searchInput.value, freeModelsCheckbox.checked);
    });
    refreshButton.addEventListener("click", async () => {
      if (!this.settings.apiKey) {
        new import_obsidian.Notice("API key not set. Please set it in the settings.");
        return;
      }
      refreshButton.disabled = true;
      refreshButton.innerHTML = "\u231B";
      const success = await this.plugin.fetchOpenRouterModels();
      refreshButton.disabled = false;
      refreshButton.innerHTML = "\u27F3";
      if (success) {
        new import_obsidian.Notice("Models refreshed successfully");
        this.populateModelSelect(modelSelect, searchInput.value, freeModelsCheckbox.checked);
      }
    });
    contentEl.createEl("h3", { text: "Prompt:" });
    const promptContainer = contentEl.createEl("div", { cls: "openrouter-modal-prompt" });
    promptContainer.setText(this.prompt);
    contentEl.createEl("h3", { text: "Response:" });
    const responseContainer = contentEl.createEl("div", { cls: "openrouter-modal-response" });
    responseContainer.setText("Response will appear here...");
    const buttonContainer = contentEl.createEl("div", { cls: "openrouter-modal-buttons" });
    const generateButton = buttonContainer.createEl("button", {
      cls: "openrouter-modal-generate",
      text: "Generate"
    });
    const insertButton = buttonContainer.createEl("button", {
      cls: "openrouter-modal-insert",
      text: "Insert",
      attr: { disabled: true }
    });
    const cancelButton = buttonContainer.createEl("button", {
      cls: "openrouter-modal-cancel",
      text: "Cancel"
    });
    generateButton.addEventListener("click", async () => {
      var _a;
      if (this.isProcessing)
        return;
      this.isProcessing = true;
      generateButton.setText("Generating...");
      generateButton.setAttribute("disabled", "true");
      responseContainer.setText("Thinking...");
      try {
        const messages = [
          { role: "system", content: this.settings.systemMessage },
          { role: "user", content: this.prompt }
        ];
        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${this.settings.apiKey}`,
            "HTTP-Referer": "https://obsidian.md",
            "X-Title": "Obsidian OpenRouter Plugin"
          },
          body: JSON.stringify({
            model: modelSelect.value,
            messages
          })
        });
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(((_a = errorData.error) == null ? void 0 : _a.message) || `HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        this.resultText = data.choices[0].message.content;
        responseContainer.setText(this.resultText);
        insertButton.removeAttribute("disabled");
      } catch (error) {
        console.error("Error calling OpenRouter:", error);
        responseContainer.setText(`Error: ${error.message}`);
      }
      this.isProcessing = false;
      generateButton.setText("Generate");
      generateButton.removeAttribute("disabled");
    });
    insertButton.addEventListener("click", () => {
      this.onSubmit(this.resultText);
      this.close();
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var OpenRouterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "OpenRouter Chat Settings" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your OpenRouter API key. Get one at https://openrouter.ai/keys").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("System Message").setDesc("System message for the chat. This sets the personality and constraints for the AI.").addTextArea((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemMessage).onChange(async (value) => {
      this.plugin.settings.systemMessage = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Model Selection" });
    const modelSearchSetting = new import_obsidian.Setting(containerEl).setName("Search Models").setDesc("Search for models by name or provider");
    this.modelSearchInput = document.createElement("input");
    this.modelSearchInput.type = "text";
    this.modelSearchInput.placeholder = "Search models...";
    this.modelSearchInput.className = "openrouter-model-search";
    modelSearchSetting.controlEl.appendChild(this.modelSearchInput);
    const freeModelsSetting = new import_obsidian.Setting(containerEl).setName("Free Models Only").setDesc("Show only models that are free to use");
    this.freeModelsCheckbox = document.createElement("input");
    this.freeModelsCheckbox.type = "checkbox";
    this.freeModelsCheckbox.checked = this.plugin.settings.showFreeModelsOnly;
    freeModelsSetting.controlEl.appendChild(this.freeModelsCheckbox);
    const modelSetting = new import_obsidian.Setting(containerEl).setName("Default Model").setDesc("Select the default model to use for chat");
    this.modelSelect = document.createElement("select");
    this.modelSelect.className = "openrouter-model-select";
    modelSetting.controlEl.appendChild(this.modelSelect);
    this.populateModelSelect("", this.freeModelsCheckbox.checked);
    this.modelSelect.addEventListener("change", async () => {
      this.plugin.settings.defaultModel = this.modelSelect.value;
      await this.plugin.saveSettings();
    });
    this.modelSearchInput.addEventListener("input", () => {
      this.populateModelSelect(this.modelSearchInput.value, this.freeModelsCheckbox.checked);
    });
    this.freeModelsCheckbox.addEventListener("change", () => {
      this.plugin.settings.showFreeModelsOnly = this.freeModelsCheckbox.checked;
      this.plugin.saveSettings();
      this.populateModelSelect(this.modelSearchInput.value, this.freeModelsCheckbox.checked);
    });
    new import_obsidian.Setting(containerEl).setName("Refresh Models List").setDesc("Fetch the latest models from OpenRouter").addButton((button) => button.setButtonText("Refresh Models").onClick(async () => {
      if (!this.plugin.settings.apiKey) {
        new import_obsidian.Notice("API key not set. Please set it in the settings.");
        return;
      }
      button.setButtonText("Refreshing...");
      button.setDisabled(true);
      const success = await this.plugin.fetchOpenRouterModels();
      button.setButtonText("Refresh Models");
      button.setDisabled(false);
      if (success) {
        new import_obsidian.Notice("Models refreshed successfully");
        this.populateModelSelect(this.modelSearchInput.value, this.freeModelsCheckbox.checked);
      }
    }));
    if (this.plugin.settings.lastModelUpdate > 0) {
      const dateString = new Date(this.plugin.settings.lastModelUpdate).toLocaleString();
      containerEl.createEl("div", {
        cls: "openrouter-last-update",
        text: `Last models update: ${dateString}`
      });
    }
    containerEl.createEl("hr");
    const aboutDiv = containerEl.createEl("div", {
      cls: "openrouter-about"
    });
    aboutDiv.createEl("h3", { text: "About" });
    aboutDiv.createEl("p", { text: "OpenRouter Chat is a plugin that allows you to chat with various AI models through the OpenRouter API. Visit https://openrouter.ai for more information." });
  }
  populateModelSelect(searchText = "", freeOnly = false) {
    this.modelSelect.innerHTML = "";
    const models = this.plugin.getModelsForDisplay(searchText, freeOnly);
    const modelsByProvider = {};
    models.forEach((model) => {
      if (!modelsByProvider[model.provider]) {
        modelsByProvider[model.provider] = [];
      }
      modelsByProvider[model.provider].push(model);
    });
    Object.keys(modelsByProvider).sort().forEach((provider) => {
      const optgroup = document.createElement("optgroup");
      optgroup.label = provider;
      this.modelSelect.appendChild(optgroup);
      modelsByProvider[provider].forEach((model) => {
        let displayName = model.name;
        if (model.isFree && !model.name.toLowerCase().includes("free")) {
          displayName += " (Free)";
        }
        const option = document.createElement("option");
        option.value = model.id;
        option.text = displayName;
        if (model.id === this.plugin.settings.defaultModel) {
          option.selected = true;
        }
        optgroup.appendChild(option);
      });
    });
    if (models.length === 0) {
      const option = document.createElement("option");
      option.value = "";
      option.text = "No models match the filter";
      option.disabled = true;
      option.selected = true;
      this.modelSelect.appendChild(option);
    }
  }
};
